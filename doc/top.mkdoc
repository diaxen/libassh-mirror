@c
@c Default top.mkdoc file for C projects copied by mkdoc
@c

@include template.mkdoc

@c Create a modules.mkdoc file, add modules delcarations and uncomment
@c these line to use modules.

@c @include modules.mkdoc

@macro rfc number
  @xref {rfc@number@}{rfc@number@}
@end macro

@macro wp article text
  @url {https://en.wikipedia.org/wiki/@article@}{ @text@ }
@end macro

@parse {
doc/config.h
assh/assh.h
assh/assh_platform.h
assh/assh_algo.h
assh/assh_alloc.h
assh/assh_bignum.h
assh/assh_cipher.h
assh/assh_compress.h
assh/assh_connection.h
assh/assh_context.h
assh/assh_hash.h
assh/assh_kex.h
assh/assh_key.h
assh/assh_mac.h
assh/assh_map.h
assh/assh_packet.h
assh/assh_buffer.h
assh/assh_prng.h
assh/assh_queue.h
assh/assh_service.h
assh/assh_session.h
assh/assh_sign.h
assh/assh_transport.h
assh/assh_userauth_client.h
assh/assh_userauth_server.h
assh/assh_userauth.h
assh/helper_io.h
assh/helper_key.h
assh/helper_bcrypt.h
assh/helper_client.h
assh/helper_server.h
assh/helper_base64.h
assh/helper_interactive.h
assh/key_dsa.h
assh/key_eddsa.h
assh/key_ecdsa.h
assh/key_rsa.h
assh/assh_event.h
}

@insert title

@ifnopt html_side_toc
  @section PH {Table of contents}
    @insert toc
  @end section
@end if

@section TP {Sales pitch}

  @em libassh is a free software library written in C which implements
  the @invoke{Secure Shell}{Secure Shell}wp protocol version 2. The
  client and server sides are implemented with the same set of
  features.

  Its design supports portability, reliability and small footprint.
  This makes @em libassh a good choice to implement embedded ssh
  clients and servers.  It strives to let the application access every
  feature of the protocol so that it can be used to implement full
  featured ssh client and server applications as well.

  It comes with a test suite, some @xref{example} applications and the
  @sinvoke{RTFM}{fine manual}wp you are reading. A contributor manual
  with details of the internal API is also available.

  @section T {Event based ssh}
    The API has been designed to support both, @sinvoke{Asynchronous
    I/O} {asynchronous}wp and synchronous types of programming
    interfaces of the application and operating system.

    The core library does not provides blocking functions nor does it
    rely on a callback based API. Instead, the library reports
    @xref{events} which do not require immediate processing by the
    application. This design is agnostic with regard to the
    @sinvoke{{Programming model}{programming model}wp. It allows easy
    integration in applications, including those based on
    @sinvoke{Event loop} {event loops}wp provided by existing
    libraries and toolkits.

    Moreover, this design fully supports the asynchronous nature of
    the @em ssh2 protocol. This does not only mean that the library
    calls are non-blocking, it is also able to handle out of order
    operations allowed by the protocol. This includes handling and
    replying to multiple @xref {channel} related messages out of order.

    The lack of an @em ssh2 library written in C with this design
    has been the main reason of starting the project.
  @end section

  @section T {Modular ssh}
    The @em ssh2 protocol is specified in a modular way so that
    implementers can freely add new crypto @xref {algorithms}, new
    @xref{services} and new @xref{user authentication} methods without
    breaking compatibility with other implementations.

    The @em libassh implementation of @em ssh2 is modular, as allowed
    by the specification. It supports working with @em ssh2
    @xref{coremod}{software components} that are not provided with the
    library. This includes dynamically registering additional @em
    ssh2 @xref {algorithms} as well as running custom @em ssh2
    @xref{services}. Moreover it allows using an external memory
    allocator and working with an external random number generator.
  @end section

  @section T {Clean design}
    The modular design makes the code more readable by not including
    crypto algorithms specific code in the core protocol
    implementation. This approach enforces uses of well defined and
    documented APIs between the software components, which eases the
    code review process and allows writing unit tests.

    Although it's well known that basing protocol implementations on
    @sinvoke{Finite-state machine}{finite state machines}wp helps
    excluding unforeseen protocol states and improves identification
    of all possible edge conditions, the @em ssh2 specification does
    not provide a state based description of the protocol
    @xref{trspec01}.  As a consequence, many implementations of @em
    ssh2 do not rely on finite state machines. Protocol state fuzzing
    techniques are needed in order to extract state diagrams and
    perform a partial analysis of their corner case behavior @xref
    {model01} @xref {infer01} @xref {model02}.

    The @em libassh implementation is based on multiple state
    machines.  Using separate state machines for the various parts of
    the protocol helps avoiding unexpected interactions between the
    layers @xref {infer01}. The state machines implemented in @em
    libassh are documented in the provided @xref {fsms} {state diagrams}.

    No global variables are used and multiple library @ref
    assh_context_s {contexts} and @ref assh_session_s {sessions} can
    be created. This makes the library safe to use in multi-threaded
    applications.
  @end section

  @section T {Portable ssh}
    @em libassh has been designed to run on a variety of platforms
    ranging from UNIX servers to embedded devices with bare metal
    implementations.

    The library core only contains algorithmic stuff, mostly protocol
    state machines. It has no dependencies other than the standard C
    library and perform no operating system calls. The library returns
    specific @xref{events} in order to let the
    application transfer the @em ssh2 stream over any reliable data
    pipe, usually a TCP connection.

    This makes this @em ssh2 implementation portable on any platform
    provided that a support for standard C is available. This
    @xref{softarch} {architecture} requires the library
    user to develop some glue code for the target platform. This code
    is provided in the form of helper functions for convenient use on
    @em POSIX platforms. Optional support for file formats used by
    @em OpenSSH is provided as well.

    Because the library comes with a set of standard @em ssh2
    @xref{algorithm} implementations, it can be used
    standalone. Alternate modules relying on external libraries like
    @em Libgcrypt, @em OpenSSL and and @em Zlib are available in order
    to further extend the set of @xref {supported algorithms}.

    The clear @xref{source tree}{source organization} and file naming
    helps identify the core components and modules.
  @end section

  @section T {Security}
    The library implements several security related features.

    It comes with implementations of many @em ssh2 @xref {algorithms},
    support for common @xref {user authentication} methods and
    @xref{key formats}. Passphrase encrypted @xref{SSH keys} can be
    loaded and saved. The library is also able to generate new user
    and @xref{host keys}.

    Because using fast and secure @em ssh2 @xref {algorithms} among
    those supported by the remote peer is the most desirable thing for
    the user, the library is able to compute a simple score which can
    be used to advertise the overall level of security of a
    @xref{session}. This is based on @xref {algorithms} negotiated
    during the @xref{key-exchange} as well as involved @xref{host
    keys}. It is also possible to select and sort @xref {algorithms}
    based on their speed and safety before running a
    @xref{session}. This helps the user keep control without having to
    know strengths and weakness of the various crypto @xref
    {algorithms}.

    @sinvoke{Multi-factor authentication}{Multi-factor user
    authentication}wp and password change requests are both
    supported. In order to enable use of hardware authentication
    tokens, the @xref{user authentication} code is able to work with
    both, internally and externally generated signatures.

    Providing those feature is not sufficient to make the
    implementation reliably secure, that's why special care has been
    taken to avoid leaking secret material.  In order to mitigate
    @sinvoke{Side-channel attack}{side channel attacks}wp, all
    implementations of public key cryptography relies on a big number
    engine with strict constant time operations.  Moreover, the
    library can be configured to store sensitive data and temporary
    buffers in secure memory.
  @end section

  @section T {Performances}
    The library uses a @sinvoke{Zero-copy}{zero copy}wp approach to
    pass data between the network stream, the @xref{channels} and the
    application. This is achieved by giving the application a direct
    access to buffers stored in the packet objects. Moreover the
    application is allowed to take full control of the @xref {channel}
    flow control mechanism specified in @sinvoke{4254}rfc.

    An optional packet pool allocator is provided in order to recycle
    packets and reduce pressure on the memory allocator.

    A large set of compile time @xref{Build configuration}{configuration
    macros} is available which allows optimization of the library
    footprint on embedded targets. The modular design allows retaining
    only a small set of @em ssh2 @xref {algorithms} and makes it
    easy to add support for hardware cryptographic accelerators.

    The library only needs to allocate a few kilobytes in order to run
    a client or server @xref{session}.
  @end section

  @section T {Test suite}
    The library comes with unit tests and stress tests for its various
    software components. It helps ensure that the implementation
    follows the standard and behaves well on corner cases.

    Stress tests are implemented by making the server and client sides
    talk to each other, performing many @xref{key-exchange},
    @xref{user authentication} and @xref {channel} operations per
    second. Because the library is not bound to a particular network
    stack, the two instances under test are able to efficiently
    exchange the @em ssh2 stream using memory buffers in the same
    program.

    Fuzzing is used in order to reach more corner cases. Randomly
    corrupted packets and random memory allocation failures are
    injected while the library is tested for compliance and memory
    leaks.

    In order to keep @em libaash compatible with other implementations
    of @em ssh2, a @xref{session} replaying tool is also provided. It
    allows including regression tests against other implementations as
    part of the test suite. Because it records and replays sessions at
    the packet level, other implementations do not need to be
    available when running the tests.
  @end section

@end section

@section TP {Quickstart}
  @list
    @item Get the code, configure, build, install ... as usual,
    @item If your are not familiar with the @em ssh2 protocol
      internals, read the @xref{Protocol architecture} section,
    @item Then read the @xref{Event based API} section,
    @item Have a look to the @xref {examples},
    @item Start hacking,
    @item Read the whole manual before asking questions.
  @end list
@end section

@section TP {Design and architecture}
  @label{softarch}

  The architecture of the @em ssh2 protocol and the software
  architecture of @em libassh are tightly coupled. The following
  subsections describe both and present some software design choices.

  @section TP {Protocol architecture}

    This section gives a brief overview of the @em ssh2 protocol
    architecture and internal working. You may skip to the next
    section if you are familiar with the @em ssh2 protocol
    specifications.

    This overview is useful when working with @em {libassh}. It is
    assumed that the reader knows the features offered by the @em ssh2
    protocol and is familiar with design of network protocols. The
    @xref{SSH Lexicon} section gives the meaning of some SSH related
    terms.

    The specification of the @em ssh2 protocol is available as a set
    of @em rfc documents, starting with @sinvoke{4250}rfc. Many other
    documents specify extensions to the protocol. Most extensions do
    not need to amend the original specification because @em ssh2 was
    originally designed with extensibility in mind.

    Many features of the protocol like @xref{algorithms} and services
    are identified and negotiated using textual names. This allows
    alternatives to be developed without breaking compatibility with
    the base protocol and its original set of features. @xref{Private
    extensions} are allowed and should use names containing the @em{@}
    character.

    According to @sinvoke{4251}rfc, there are three major components
    in the @em ssh2 protocol architecture:
    @list
      @item the @em {Tranport Layer Protocol}, specified in @sinvoke{4253}rfc,
      @item the @em {User Authentication Protocol}, specified in @sinvoke{4252}rfc and 
      @item the @em {Connection Protocol}, specified in @sinvoke{4254}rfc.
    @end list

    These components are described in the following subsections.

    @section T {Transport layer and packets}
      @label {trlayer}

      The transport layer is able to build, compress, encipher,
      decipher, authenticate and parse @em ssh2 packets. It dispatches
      and collect packets to and from the other software
      components. Unlike other components, the transport layer is
      always running.

      The transport layer needs a reliable data pipe in order to
      exchange packets between the client and server instances. A TCP
      @xref{connection} is commonly used.

      The first step of the protocol consists in exchanging
      @xref{version strings}. Once both sides have transmitted their
      @xref{version strings} in a human readable format, they switch
      to the @em ssh2 binary packet format.

      Binary packets are variable sized arrays of bytes. A packet has
      a size header and a numerical message identifier which
      determines its role in the protocol. The interpretation of the
      packet content depends on the message id. Dispatching packets to
      the other layers does not require nesting multiple packet
      headers. There is a single header and the message identifier is
      used to dispatch packets to the right software component.

      The format of the packet content also depends on the message
      identifier. Most of the time, the content is composed of some 8
      bits and 32 bits fixed size fields as well as some variable
      sized fields which use a 32 bits length header.

      By looking at the @ref assh_ssh_msg_e enum, it is easy to see
      that there are four categories of messages:

      @list
        @item Transport related messages, starting at id 1,
        @item @xref{Key-exchange} related messages, starting at id 30,
        @item @em {User Authentication Protocol} messages, starting at
          id 50 and
        @item @em {Connection Protocol} messages, starting at id 80.
      @end list

      Some of the message identifiers used by parts of the protocol
      have multiple meaning. This is because some parts of the
      protocol are specified and implemented as extensions. The
      interpretation of those messages content do depend on the
      selected and currently running extension.

      The @em{Transport Layer Protocol} is designed so that packets
      can be processed by the selected @xref {algorithms}. However the
      binary packets are neither enciphered nor compressed before the
      end of the first @xref{key-exchange} process which performs @xref
      {algorithms} selection.

      According to the original specification, the outgoing packets
      are encrypted after appending the authentication token computed
      by the retained MAC @xref {algorithm}. This is called the @em
      {Mac-Then-Encrypt} order and allows encrypting the whole packet.

      When a more recent message authentication @xref{algorithm} is
      selected which uses the @em {Encrypt-Then-Mac} order, the size
      field has to remain in clear text so that the message
      authentication token can be located at the end of the
      undeciphered packet. This is needed because the underlying
      network pipe is stream oriented rather than datagram oriented,
      which means it is not required to preserve packets
      boundaries. This task is left to the @em ssh2 transport layer.

      When an authenticated cipher is used, no separate message
      authentication @xref{algorithm} is used. Depending on the design
      of the authenticated cipher @xref {algorithm}, the size field
      may not be enciphered. Note that hiding the actual size of the
      packets needs additional measures to be taken when transmitting
      the packets stream over the network.

      Obviously, the compression step if performed before encryption
      when present.
    @end section

    @section T {Key-exchange process and methods}
      @label {kex}

      The initial key-exchange process is started right after
      exchanging @xref{version strings} and terminates after a few
      packet exchanges. During most of the lifetime of a
      @xref{session}, no key-exchange process is running.

      Additional key-exchange processes can be initiated by either
      side at any time. This is generally requested after some amount
      of transferred data or after a delay. Processing of other
      messages is postponed during a key-exchange.

      The key-exchange process has several purposes:
      @list
        @item It negotiates the multiple @xref {algorithms} that will
          be used to secure the connection and compress the
          packets. The protocol supports using a different set of
          @xref {algorithms} for each directions, even if this is
          rarely used in practice.

          The signature @xref{algorithm} optionally involved in the
          @xref{user authentication} is @b not negotiated during the
          key-exchange process.

        @item It creates a @sinvoke{Shared secret}{shared secret}wp
          and derives the symmetric @xref{session keys} which will be
          used to encrypt and authenticate the packets using the
          selected @xref {algorithms}.

        @item It authenticates the server host using the selected
          signature algorithms. The client application is involved in
          the process because it has to decide if the @xref{host key}
          of the server is known and trusted. This is generally
          achieved by keeping track of known keys in a database and
          asking the user to check and compare the @xref{fingerprint}
          of yet unknown keys.
      @end list

      Because public key cryptography is involved, the process may be
      computationally intensive. Depending on the selected method, it
      can be costly, especially on embedded platforms.

      The key-exchange process starts when the two peers each transmit
      an @ref SSH_MSG_KEXINIT packet. This packet contains lists of
      supported @xref {algorithm} names, allowing both sides to select
      a matching set by applying the specified selection rules. For
      each type of algorithm, the first algorithm in a client list
      which appears somewhere in the associated server list is
      retained. Among the various types of @xref {algorithms}
      selected, a key-exchange method is retained and executed
      immediately.

      This method employs its own specific crypto in order to create
      the shared secret. It may however rely on an other @xref
      {algorithm} in order to authenticate the server. To achieve
      this, it needs to use specific packet exchanges until the end of
      the process. Because new key-exchange methods can be developed,
      this part of the protocol is not specified in a fixed way.
    @end section

    @section T {SSH services}
      @label {srvlayer}

      The @xref{transport layer} protocol provides a generic
      mechanism to let the client request execution of an @em ssh2
      @xref{service} by both sides.  Services are identified by textual
      names so that new one can be developed. No service is running
      initially and a single service can run at a given time.

      The two other major components of @em ssh2 are specified as
      services:

      @list
        @item The @em{User Authentication Protocol} provides several
          methods for authentication of the client user. Again,
          @xref{user authentication} methods are identified by textual
          names inside the service. This adds an additional level of
          extensibility and make some packet exchanges specific to the
          selected authentication method. The most common @xref{user
          authentication} methods are password based authentication and
          @xref{public key authentication}, but more methods are
          specified. With @xref{public key authentication}, the client user
          owns a private key which has to match the public key known
          to the server application. @label {authlayer}

        @item The @em{Connection Protocol} is designed to transfer
          data over multiplexed @em channels as detailed below. This is
          what the client and server applications generally use to
          communicate over @em {ssh2}.

        @item Although the @xref{transport layer} is designed to
          support any other kind of service, no other services are
          specified. As a result, most implementations have the two
          standard services hardwired in the same software component
          as the @xref{transport layer}.

          Supporting registration of new services allows to take
          advantage of the @em ssh2 protocol architecture for new
          usages.  This also enables running alternate implementations
          of the standard services described above. This is used in
          the @em libassh test suite in order to implement odd
          behavior while testing the real @xref{user authentication}
          service running on the other side.
      @end list

      The specification states that a service, typically the
      @em{Connection Protocol}, is run @b{on top} of the @em {User
      Authentication protocol} (@sinvoke{4252}rfc section 5.1). What
      actually happens is that the @em{Connection Protocol} service is
      run @b after the @em {User Authentication Protocol} service,
      provided that the client has requested execution of the two
      services and did so in that order. However, the server is free
      to deny execution of a service.
    @end section

    @section T {The connection protocol}
      @label {connlayer}

      The @em {ssh2 Connection Protocol} is used by applications to
      establish communications @em {channels}. Once this service is
      started, the server and the client are both allowed to open @em
      {channels} and send @em {requests}. Those are the two primitives
      offered by the connection protocol:

      @list
        @item Once opened successfully, a @em {channel} allows the two
          applications to transmit a stream of data over @em {ssh2}. A
          @em {channel} has a textual type name which identifies its
          usage. @em {Channel} open messages are transmitted by either
          side and can be accepted or rejected based on the type
          name. Opening a new @em {channel} is an asynchronous process
          and multiple open messages can be sent without waiting for
          replies. The replies can be sent in any order, so that
          connecting to a remote resource using a @em {channel} may
          take some time without blocking other @em {channels}.

          The protocol supports a windowed flow control mechanism
          which enables limiting the data throughput per @em
          {channel}. This can be used to prevent exceeding the
          capacity of the underlying transport data pipe which would
          make all @em {channels} unresponsive. @label {connchan}

        @item A @em {request} is an application
          generated message identified by a textual type name which
          may have a specific data payload attached. The sender of the
          @em {request} may or may not ask for a reply. When the
          remote application acknowledges the @em {request}
          successfully, it may also attach a payload. @em {Requests}
          can not live longer than a single round trip and must be
          replied in order. A @em {request} may be either global or
          related to an open @em {channel}. @label {connreq}
      @end list

      Some standard types of @xref {channel} and @xref {request} are
      specified for use on top of the @em ssh2 protocol:
      @list
        @item A set is specified for supporting @xref{interactive
          sessions}. This is designed to run shell instances and other
          programs on the remote server. This must not be confused
          with the term @xref{session}. Multiple @xref {interactive
          sessions} can be embedded in a single @em ssh2 @xref{session}.

          Examples of standard @xref {request} types are the @tt shell
          and @tt exec ones which request execution of a process on
          the server. Those must be related to an open @xref {channel}
          of the @tt {session} type, used to transport the standard IO
          streams of the remotely executing process.

        @item An other set is specified for supporting the TCP/IP
          @xref {port forwarding} feature. It allows the client to
          connect to a remote TCP port from the server and can also be
          used to instruct the server to listen on a TCP port and
          forward any incoming connections back to the client.
      @end list

      The application is allowed to implement private @em
      {channel} types and private @em {request} types as well.

    @end section

    @section T {Mapping to libassh components}
      Here is how the @em ssh2 protocol architecture outlined above is
      mapped to software components in the library:
      @list
        @item The @xref{transport layer} is implemented in the library
          core and relies on @xref {algorithm} @xref{coremod}{modules}
          for cryptographic processing of the packets and data
          compression. It extracts @ref assh_packet_s {packet objects}
          from the incoming @em ssh2 stream and also generates the
          outgoing @em ssh2 stream from packet objects present in the
          transmit queue. This layer handles some of the incoming
          messages and dispatches other messages either to the running
          @xref{key-exchange} method or to the running service. Transport
          related declarations can be found in
          @ref{@assh/assh_transport.h}.
        @item The @xref{key-exchange} methods and the services both have
          their own module interface. Among all @xref{coremod}{module
          interfaces} defined, only these two are designed to handle
          packet exchanges and may report @xref{events} to the
          application. Related declarations can be found in
          @ref{@assh/assh_kex.h} and @ref{@assh/assh_service.h}.
        @item The @em {User Authentication Protocol} use the @ref
          assh_service_s {service} module interface. There are
          actually two separate modules which implement the server and
          client sides of the service. Related declarations can be
          found in @ref{@assh/assh_userauth_client.h} and
          @ref{@assh/assh_userauth_server.h}.
        @item The @em {Connection Protocol} also use the service
          module interface. Because this protocol is symmetric, there
          is a single module which implements both, the client and
          server sides. The @xref {Connection protocol API} section
          explains which part of the specification is actually
          implemented by the module. Related declarations can be found
          in @ref{@assh/assh_connection.h}.
      @end list
    @end section

  @end section

  @section TP {Software interfaces}

    The following subsections describe the modular architecture of the
    library and the design of its programming interface.

    @section TP {Core and modules}
      @label{coremod}
      @label{module}

      Extensibility advertised in the standard is transposed in the
      library implementation by allowing dynamic registration of
      external @em ssh2 @xref{algorithms} and @xref {services}.

      The core of the library implements the @xref {transport layer},
      dispatches packets and @xref {events}, handles registration of
      @xref {algorithm} @xref {coremod} {modules} and performs
      management of @ref {assh_context_s} and @ref {assh_session_s}
      objects.

      Interface descriptor structures are used in order to declare
      modules. The following descriptors are used for @em ssh2
      @xref {algorithms} negotiated during the @xref{key-exchange} process:
      @list
        @item The @ref assh_algo_kex_s interface descriptor, used to declare
          @xref{kexalgos}{key-exchange algorithms}.
        @item The @ref assh_algo_sign_s interface descriptor, used to
          declare @xref{authalgos}{signature algorithms}, used for
          server @xref{host authentication} as well as user
          @xref{public key authentication}.
        @item The @ref assh_algo_cipher_s interface descriptor, used
          to declare @xref{cipheralgos}{cipher algorithms}.
        @item The @ref assh_algo_mac_s interface descriptor used to
          declare @xref{macalgos}{message authentication}.
        @item The @ref assh_algo_compress_s interface descriptor, used
          to declare data @xref{compalgos}{compression methods}.
      @end list
      Those descriptor structures inherit from the @ref assh_algo_s
      structure.

      Additional pluggable interface descriptors are used by the library:
      @list
        @item The @ref assh_service_s interface descriptor, used to
          implement named @em ssh2 @xref {services}.
        @item The @ref assh_prng_s interface descriptor, used by the
          core and modules when generation of random data is
          needed.
        @item The @ref assh_allocator_t function pointer type, used by
          the core and modules in order to allocate and free memory.
        @item The @ref assh_key_algo_s interface descriptor used to
          create and manage storage of @xref{SSH keys}.
        @item The @ref assh_hash_algo_s interface descriptor, used
          internally by the core and modules in order to specify hash
          functions to use.
      @end list

    @end section

    @section TP {Event based API}
      @label {evts}
      @label {event} {event}
      @label {events} {events}

      The programming interface is event based. Event objects are used
      to pass data between the library and the application. The
      application have to perform pairs of calls to the @ref
      assh_event_get and @ref assh_event_done functions in order to
      run a @xref{session}. These functions actually run the protocol
      @xref{fsms}{state machines}. The code below shows a simple
      construct which can be used for that purpose.

      @code
struct assh_event_s ev;

while (assh_event_get(session, &ev, time(0)))
  {
    assh_error_t err = ASSH_OK;

    switch (ev.id)
      {
        ...
      }

    assh_event_done(&session, &ev, err);
  }
      @end code

      A processing @ref{assh_error_e}{error code} can be reported
      to the library when acknowledging an event.

      The event structure contains @tt const fields and writable
      fields. Constant fields are meant to pass values from the library
      to the application and writable fields are meant to pass values
      back to the library. All event writable fields are initialized
      with default values so that any event not handled by the
      application can be acknowledged directly.

      The code code below handles the @ref ASSH_EVENT_READ event by
      retrieving the ssh stream from a network socket using the @tt read
      system call.

      @code
switch (ev.id)
  {
  case ASSH_EVENT_READ: {
    ssize_t r = read(socket, ev.transport.read.buf.data,
                             ev.transport.read.buf.size);
    if (r > 0)
      ev.transport.read.transferred = r;
    else
      err = ASSH_ERR_IO;
    break;
  }

    ...

  default:
    break;
  }
      @end code

      Because the event API is designed to let the application access
      most features of the ssh protocol, event objects reflect concepts
      used at the protocol level. Handling most of them involve some
      work in order to behave as a usual client or server
      application. In order to handle those events, the application may
      either relies on the provided @xref{helper functions} or
      implement the whole thing. In the code below, helper functions are used:

      @code
switch (ev.id)
  {
  case ASSH_EVENT_READ:
  case ASSH_EVENT_WRITE:
    assh_fd_event(&session, &ev, socket);
    continue;

  case ASSH_EVENT_KEX_HOSTKEY_LOOKUP:
    assh_client_event_openssh_hk_lookup(&session, ..., &ev);
    continue;

  ...
  }
      @end code

      This describes how events reported by the library can be handled
      in a loop. In order to adapt to the programming model of the
      application, other programming constructs may be used as well. The
      application may well start an asynchronous operation in response
      to an event then call the @ref assh_event_done function from one
      of its callback when the operation has completed. Any model will
      work provided that an event reported by the library is
      acknowledged by the application at any later time.

      Most @xref {examples} applications provided with the
      library do implement handling of @em libassh events.

    @end section

    @section TP {Helper functions}
      @xref{evts}{Events} are used to notify and involve the
      application in most packet exchanges that occur with the remote
      peer. Events reported to the application can be generated by the
      @xref{transport layer}, the running @xref{key-exchange}
      module and the running @xref{service} module.

      This makes the application responsible for performing tasks like
      @xref{host key} lookup, user credentials checking,
      @xref{requests} handling and @xref{channels} management. This
      allows a fine-grained control of the @em ssh2 features while
      letting the library handle the protocol and crypto stuff.

      This however means that there is a part of the job left to be
      done by the application. That's why the library comes with
      helper functions designed to handles events in a way which yield
      common behavior. For instance, this includes performing
      @xref{host key} lookup in standard file locations and handling
      @xref{user authentication} using the operating system calls. Of
      course, the application writer is free not to use the helper
      functions when they are not suitable. The code of the @xref
      {exremote} example and @xref {exloopback} example are short
      because helpers are used extensively.
    @end section

    @section TP {Connection protocol API}
      @label {connapi}

      The @em ssh2 @xref {connection protocol} is implemented
      as a service module. This is the top layer of the @em ssh2
      protocol and the application usually wants to interact with it.

      The module implements the generic @xref{request} and @xref
      {channel} mechanisms specified in sections 4 and 5 of
      @sinvoke{4254}rfc and nothing more. The module reports events
      which allow the application to handle incoming @xref {request}
      and @xref {channel} related messages. It also provides functions
      to send @xref {requests} and manage @xref {channels} but it does
      not care about the types of @xref {request} and @xref {channel}
      used. It makes no difference if those have a standard type or
      are @xref{private extensions}. The related declarations and
      details of the module API can be found in
      @ref{@assh/assh_connection.h}.

      Section 6 and 7 of the same specification describe some standard
      @xref {channel} and @xref {request} types which support @xref
      {interactive sessions} and @xref {port forwarding}
      respectively. Because implementation of these features is
      tightly coupled with both, the operating system and usage,
      handling of these features is left to the application. Some
      parsing functions and a basic client state machine for @xref
      {interactive Sessions} is provided as @xref{helper functions} as
      shown in the @xref{exremote} and @xref{exserver} examples. The
      related declarations can be found in
      @ref{@assh/helper_interactive.h}.
    @end section

    @section TP {Time management}
      The library is able to compute protocol deadlines, provided that
      the application pass the current time to the @ref assh_event_get
      function.

      The @ref assh_session_deadline and @ref assh_session_delay
      functions can be used in order to get the next protocol
      deadline. This allows the application to stop waiting on IOs
      after the right amount of time in order to let the library
      handle the timeout.

      The @ref assh_context_timeouts and @ref assh_context_keepalive
      functions can be used to change the protocol delays.
    @end section

  @end section

  @section TP {State machines}
    @label{fsms}

    This section gives an overview of the library internal working. It
    describes the @sinvoke{Finite-state machine}{finite state
    machines}wp (FSM) used to implement the @em ssh2 protocol in the
    library.

    @section T {Transport layer FSMs}
      The @xref{transport layer} is implemented using four
      finite state machines:
      @list
        @item The main @xref{fsmtr}{transport FSM} tracks the state of
          the @ref assh_session_s object. It manages the different
          phases of the protocol, starting with exchange of
          @xref{version strings}. It also dispatches packets to the
          running @xref{key-exchange} module and to the service
          FSM. It handles disconnection as well.
        @item The @xref{fsmin}{input FSM} retrieves the remote ssh
          stream from the application then extracts, decipher,
          authenticate and decompress packets.
        @item The @xref{fsmout}{output FSM} enciphers outgoing
          packets and report the output ssh stream to the application
          for sending to the remote host.
        @item The @xref{fsmsrv}{service FSM} manages selection and
          execution of the @em ssh2 @xref{services} which run on top
          of the @xref{transport layer}. On a client @xref{session},
          the @em{service FSM} send service requests to the server,
          then initializes and run the next service. On a server
          @xref{session}, the @em{service FSM} wait for client
          requests, then initializes and run the requested service.
      @end list

      The state of these FSMs are updated when the @ref assh_event_get
      and @ref assh_event_done functions are called by the application.

      The library behaves as follows when the @ref assh_event_get
      function is called:
      @list
        @item It report any pending error event.
        @item It checks for protocol timeouts.
        @item It dispatches an incoming packet to the running
          @xref{key-exchange} module if any. When none is running, it
          dispatches to the @em {service FSM} instead.
        @item It lets the running @xref{key-exchange} or
          @xref{service} report an event to the application.
        @item If no event has been reported, the @em{output FSM} is
          executed, unless disconnected from the remote peer. This may
          report an @ref ASSH_EVENT_WRITE event to the application.
        @item If no event has been reported by the @em{output FSM},
          the @em{input FSM} is executed, unless disconnecting. This
          reports an @ref ASSH_EVENT_READ event to the application.
      @end list

      The behavior of the @ref assh_event_done function depends on the
      reported event. It calls a function provided by the @em libassh
      software component which reported the event.

    @end section

    @section T {User auth FSMs}
      Client and server @xref{user authentication} components are
      implemented as two different service modules. They each have
      their own FSM.

      The @xref{fsmcauth}{client user
      authentication FSM} handles authentications requests from the
      application and forward them to the remote server.

      The @xref{fsmsauth}{server user
      authentication FSM} replies to authentications requests from the
      remote client under supervision of the application.
    @end section

    @section T {Connection layer FSMs}
      The module which implements the @xref{connection protocol} is
      identical for server and client sides. It relies on two
      different types of FSMs which are instantiated for each @xref
      {channel} and @xref {request} objects.

      The @xref {fsmchan}{channel FSM} manages the @xref {channel}
      protocol state and lifetime. It ensures that any @xref {channel}
      object known to the application will be properly reported as
      released at some point even in case of disconnection.

      The @xref {fsmrq}{request FSM} is used to reorder request
      replies so that the application can handle them out of order.
    @end section

    @section T {Key exchange FSMs}
      The various @xref{key-exchange} modules all use their own FSM in
      order to execute the @xref{key-exchange} process. Because those
      FSMs are very simple and linear, no state diagrams are provided.
    @end section

  @end section

  @section TP {Source tree}

    This section gives an overview of the source code organization. It
    is of interest for those writing new modules and playing with the
    library internal.

    The source tree is organized as follow:
    @list
      @item @tt{src/} : The source code of the library
        @xref{coremod}{core and modules}.
      @item @tt{src/assh/} : The library public headers. See the
        @xref{headers list} section for details.
      @item @tt{tests/} : The test suite.
      @item @tt{doc/} : This manual.
      @item @tt{examples/} : Some @xref{examples}{example applications}.
      @item @tt{extra/} : development tools used to generate some tables and code.
    @end list

    The library core and @xref{service} modules only
    contains the @xref{state machines} and protocol related stuff:
    @list
      @item @tt{src/assh_*.c} : The library core functions. This
        includes code related to management of @ref assh_context_s
        {contexts}, @ref assh_session_s {sessions}, @ref assh_event_s
        {events}, as well as support code for @xref{key-exchange}, @ref
        assh_service_s {services}, @ref assh_packet_s {packets}, @ref
        assh_key_s {keys} and @ref assh_algo_s {algorithms}.
      @item @tt{src/assh_transport.c} : The @xref{transport layer}
        implementation.
      @item @tt{src/assh_userauth_client*.c} : The client side
        @xref{user authentication} service module.
      @item @tt{src/assh_userauth_server*.c} : The server side
        @xref{user authentication} service module.
      @item @tt{src/assh_connection.c} : The
        @xref{connection protocol} service module.
    @end list

    Then come the @xref {algorithms} exposed during the negotiation
    phase of the ssh protocol. Some of these pluggable modules are
    standalone and others are linked to an external libraries:
    @list
      @item @tt{src/kex*.c} : The ssh @xref{kexalgos}{key-exchange algorithm modules}.
      @item @tt{src/sign*.c} : The ssh @xref{authalgos}{signature algorithm modules}.
      @item @tt{src/cipher*.c} : The ssh @xref{cipheralgos}{cipher algorithm modules}.
      @item @tt{src/mac*.c} : The ssh @xref{macalgos}{MAC algorithm modules}.
      @item @tt{src/compress*.c} : The @xref{compalgos}{ssh compression algorithm modules}.
    @end list

    Some additional pluggable utility components are used by the library
    @xref{coremod}{core and modules}:
    @list
      @item @tt{src/key*.c} : @xref{SSH keys} management modules.
      @item @tt{src/prng*.c} : Random number generation modules.
      @item @tt{src/hash*.c} : Hash functions modules.
      @item @tt{src/bignum*.c} : A big number engine.
    @end list

    Some @xref{helper functions} are provided for
    convenience. Unlike other parts of the library, these files
    contains system calls and platform specific stuff. It is not used
    by the other parts of the library and are only provided for use by
    the application. It doesn't rely on the private APIs of the library:
    @list
      @item @tt{src/helper_client.c} : This provides event handlers
        for common ssh client behavior.
      @item @tt{src/helper_server.c} : This provides event handlers
        for common ssh server behavior.
      @item @tt{src/helper_key.c} : This provides @xref{SSH key} file
        loading and saving functions.
      @item @tt{src/helper_base64.c} : This implements a base64
        encoder and decoder for use by @xref{SSH key} helpers.
      @item @tt{src/helper_bcrypt.c} : This provides the encryption
        algorithm used for passphrase protected keys in @em OpenSSH
        formats.
      @item @tt{src/helper_io.c} : This provides IO events handler
        relying on POSIX file descriptors.
      @item @tt{src/helper_interactive.c} : This implements
        @xref{interactive session} related functions.
    @end list
    See associated header files for details of the helpers API.
  @end section

  @section TP {Build configuration}

    Various macros allow configuration of the library at build time. It
    can be used to select the software components included in the build
    and tweak some values.

    When compiled with the provided @tt configure script, some of these
    features can be changed by using appropriate command line options.

    When porting the library to a custom platform, these macros need to
    be defined properly. This can be achieved by providing an @tt
    assh_config.h file and defining the @tt HAVE_CONFIG_H macro.

    The available macros are described in @ref{@doc/config.h}{this
    sample header file}.

    The @tt config_tests.mk make script can be used to build and test
    the library with different sets of feature enabled.

  @end section
@end section


@section TP {Supported algorithms}
  @label{suppalgos}

  The @em ssh2 protocol is designed for extensibility as described in
  the @xref {Protocol architecture} section.

  When the @xref{key-exchange} process starts, the peers agree on the
  @em ssh2 @xref {algorithms} that will be used to secure the
  connection. There are five types of @xref {algorithms} which need to
  be agreed upon: @xref{kexalgos}{key-exchange algorithms},
  @xref{authalgos}{host authentication algorithms},
  @xref{cipheralgos}{cipher algorithms}, @xref{macalgos}{message
  authentication algorithms} and @xref{compalgos}{compression
  algorithms}. The following subsections list supported algorithms for
  each type.

  The library comes with @xref{coremod}{modules} which implement
  various @xref {algorithms} for the @em ssh2 protocol. Some provided
  modules use builtin crypto implementation and other rely on external
  libraries like @em Libgcrypt and @em OpenSSL. Additional modules can
  be added in order to support alternate implementations as well as
  new algorithms and hardware acceleration.

  A subset of the provided modules allows running the @em ssh2
  protocol without relying on any external library. Currently, most
  provided modules which implement asymmetric cryptography use
  built-in implementation. They rely on the internal big number
  engine which implements constant time operations. This includes
  @xref{kexalgos}{key-exchange algorithms} and @xref{authalgos}{host
  authentication algorithms}.

  The library offers multiple mechanisms to shape the set of
  @xref{algorithms} involved in a @em libassh @xref{session}:
  @list
    @item The first selection is performed when registering the
      @xref{algorithms} on the @ref assh_context_s {context
      object}. Depending on the library function used for that
      purpose, a specific list of @xref {algorithms} is provided by the
      application, or the library filters among the supported
      @xref {algorithm} based on the safety requirement provided by the
      application.
    @item When multiple variants of the same @xref {algorithm} are
      available, the one with the lower safety which matches the
      requirement is retained. The application is free to use a low
      safety factor in order to favor acceptance of weak keys and weak
      parameters. It may also use a higher safety factor which may
      prevent connecting with older unsafe implementations and reject
      weak user and @xref{host keys}.
    @item An additional filter callback function can be used on a per
      @xref{session} basis to further filter among registered @xref
      {algorithms} during the @xref{key-exchange} process. Because
      some @xref {algorithms} are available under different names,
      this callback allows filtering based on specification status as
      well as popularity. It can also be used to enable some @xref
      {algorithm} in a single direction.
  @end list

  @em Related functions are declared in @ref{@assh/assh_algo.h} and
  @ref{@assh/assh_session.h}. Available @xref {algorithms} and methods are
  listed in the following subsections.

  @section TP {Key-exchange algorithms}
    @label{kexalgos}

    Modules of this type actually implement more than cryptography. A
    key exchange module needs to provide both, the crypto used to
    establish a shared secret and the associated part of the @em ssh2
    protocol extension. See the @xref{kex} section for more details.

    This section briefly lists key-exchange @xref {algorithms} that are
    supported by modules provided with the library.

    Key-exchange related declarations can be found in @ref{@assh/assh_kex.h}.

    @section {Prime field Diffie-Hellman}
      The following @xref {algorithms} rely on diffie-hellman over prime
      field, as specified in @sinvoke{4253}rfc:
      @list
        @item @tt {diffie-hellman-group1-sha1} (1024 bits prime),
        @item @tt {diffie-hellman-group14-sha1} (2048 bits prime).
        @item @tt {diffie-hellman-group14-sha256} (2048 bits prime).
      @end list

      There are additional such @xref {algorithms} with larger primes,
      specified in @xref {draftmodp}:
      @list
        @item @tt {diffie-hellman-group15-sha512} (3072 bits prime).
        @item @tt {diffie-hellman-group16-sha512} (4096 bits prime).
        @item @tt {diffie-hellman-group17-sha512} (6144 bits prime).
        @item @tt {diffie-hellman-group18-sha512} (8192 bits prime).
      @end list
    @end section

    @section {Prime field Diffie-Hellman with group exchange}
      The following @xref {algorithms} rely on diffie-hellman over prime
      field as specified in @sinvoke{4419}rfc. The groups used are not
      fixed but provided by the server:
      @list
        @item @tt {diffie-hellman-group-exchange-sha1},
        @item @tt {diffie-hellman-group-exchange-sha256}.
      @end list
    @end section

    @section {RSA encrypted secret}
      These key exchange methods rely on RSA encrypted secret as
      specified in @sinvoke{4432}rfc:
      @list
        @item @tt {rsa1024-sha1},
        @item @tt {rsa2048-sha256}.
      @end list
      They require an RSA key on the server side. If no key is loaded
      for that purpose, an ephemeral key is created automatically.
    @end section

    @section {Montgomery curves Diffie-Hellman}
      These are diffie-hellman @xref {algorithms} based on montgomery elliptic
      curves as proposed in @xref {curve25519}. The protocol part for
      @em ssh2 is specified in @xref {curve25519libssh}.

      Two additional sets of curve parameters proposed in @xref
      {ietfladdsc} and @xref{safecurves} with larger key sizes are
      implemented as @em libassh extensions:
      @list
        @item @tt {curve25519-sha256@libssh.org},
        @item @tt {m383-sha384@libassh.org},
        @item @tt {m511-sha512@libassh.org}.
      @end list
    @end section

    @section {Weierstrass curves Diffie-Hellman}
      These are diffie-hellman @xref {algorithms} based on weierstrass
      elliptic curve as proposed in @sinvoke{5656}rfc. The three NIST
      curves required by the rfc are implemented.

      @list
        @item @tt {ecdh-sha2-nistp256},
        @item @tt {ecdh-sha2-nistp384},
        @item @tt {ecdh-sha2-nistp521}
      @end list
    @end section

  @end section

  @section TP {Authentication algorithms}
    @label{authalgos}

    Modules of this type implement signature algorithms which are used
    during the @xref{key-exchange} process.

    Those modules can also be involved in the @xref{user
    authentication} process even though the algorithm selected during
    the key-exchange is only used to authenticate the server host.

    Signature generation and checking features are provided by modules
    of this type. Companions modules with ability to create, load and
    save keys using various @xref {key formats} are provided as well.

    Signature related declarations can be found in @ref{@assh/assh_sign.h}.

    @section {DSA signature}
      These are implementations of the @em {Digitial Signature
      Algorithm} as specified in @xref{fips1864}.

      The original @sinvoke{4253}rfc only specifies use of 1024 bits
      DSA keys for @em {ssh2}. The last version of the DSA standard
      @xref{fips1864} specifies larger key sizes, implemented here as
      extensions. The additional @xref {algorithms} accept any key size
      greater than their base key size and reject shorter keys.

      @list
        @item @tt {ssh-dss} (use @em {sha1}, 1024 bits key),
        @item @tt {dsa2048-sha224@libassh.org} (key size >= 2048 bits),
        @item @tt {dsa2048-sha256@libassh.org} (key size >= 2048 bits),
        @item @tt {dsa3072-sha256@libassh.org} (key size >= 3072 bits).
      @end list
    @end section

    @section {RSA signature}
      These are implementations of the RSA signature @xref {algorithm} as
      specified in @xref{fips1864}.

      The original RSA signature @xref {algorithm} specified in
      @sinvoke{4253}rfc relies on @em{md5} and @em{sha1}
      hashes. Additional @xref {algorithms} using the @em{sha2-256} and
      the @em{sha2-512} hashes are implemented as proposed in
      @xref{draftsignsha2}.

      @list
        @item @tt {ssh-rsa},
        @item @tt {rsa-sha2-256} (key size >= 2048 bits),
        @item @tt {rsa-sha2-512} (key size >= 2048 bits).
      @end list

      Variants of the @tt {ssh-rsa} @xref {algorithms} are proposed under
      the same name. Depending on the retained variant, lower key
      sizes and weak hash algorithms will be rejected:

      @list
        @item generate @em{sha1}, accept @em{sha*} or @em{md5}, accept keys size >= 768 bits,
        @item generate @em{sha1}, accept @em{sha*}, accept keys size >= 1024 bits,
        @item generate @em{sha1}, accept @em{sha*}, accept keys size >= 2048 bits,
      @end list

      The retained variant depends of the safety value passed to the
      @ref assh_algo_register_va function.
    @end section

    @section {EdDSA signature}
      These are signature @xref {algorithms} based on Edward elliptic
      curve as proposed in @xref{hshssign}.

      Two additional sets of curve parameters with larger key sizes
      are proposed as extensions, as described in
      @xref{ietfladdsc}. Unlike @em{Ed25519} which relies on the
      @em{sha2-512} hash, the @em{sha3} hash is used for the
      extensions, as suggested in @xref{hshssign}. Variable output
      length variants of the @em {sha3} hash are needed here because
      the output of fixed size hash functions is not large enough for
      the implemented curves.

      @list
        @item @tt {ssh-ed25519},
        @item @tt {eddsa-e382-shake256@libassh.org},
        @item @tt {eddsa-e521-shake256@libassh.org}.
      @end list
    @end section

    @section {ECDSA signature}
      These are implementations of the @em{Elliptic Curve Digitial
      Signature Algorithm} as specified in @xref{fips1864} and
      @sinvoke{5656}rfc.

      @list
        @item @tt {ecdsa-sha2-nistp256},
        @item @tt {ecdsa-sha2-nistp384},
        @item @tt {ecdsa-sha2-nistp521}
      @end list
    @end section

  @end section

  @section TP {Cipher algorithms}
    @label {cipheralgos}

    Modules of this type are used by the @xref{transport
    layer} in order to encipher and decipher the @em ssh2 packets
    transmitted over the network.

    Cipher @xref {algorithms} are specified in @sinvoke{4253}rfc and
    their @em{CTR} variants are specified in @sinvoke{4344}rfc. Both
    are implemented.

    Authenticated ciphers are supported too. When one is selected, the
    use of a separate @xref{macalgos}{message authentication
    algorithm} is unnecessary. In this case, the binary packet format
    described in @sinvoke{5647}rfc is used but the @xref {algorithms}
    selection mechanism described for @tt AEAD_AES_128_GCM is broken
    by design and not implemented. What actually happens is that the
    MAC algorithm selection is ignored when an authenticated cipher is
    selected, as specified for the @tt {aes128-gcm@openssh.com}
    private @xref {algorithm}.

    Cipher related declarations can be found in @ref{@assh/assh_cipher.h}.

    The following cipher @xref {algorithms} have built-in support:
    @list
      @item @tt {chacha20-poly1305@openssh.com},
      @item @tt {aes128-cbc},  @tt {aes192-cbc},    @tt {aes256-cbc},
      @item @tt {aes128-ctr},  @tt {aes192-ctr},    @tt {aes256-ctr},
      @item @tt {arcfour},     @tt {arcfour128},    @tt {arcfour256}.
    @end list

    When the @em Libgcrypt library is used, these additional cipher
    algorithms are available:
    @list
      @item @tt {serpent128-cbc},    @tt {serpent192-cbc},    @tt {serpent256-cbc},
      @item @tt {serpent128-ctr},    @tt {serpent192-ctr},    @tt {serpent256-ctr},
      @item @tt {twofish128-cbc},    @tt {twofish256-cbc},
      @item @tt {twofish128-ctr},    @tt {twofish256-ctr},
      @item @tt {3des-cbc},      @tt {3des-ctr},
      @item @tt {cast128-cbc},   @tt {cast128-ctr},
      @item @tt {blowfish-cbc},  @tt {blowfish-ctr}.
      @item @tt {aes128-gcm@openssh.com}, @tt {aes256-gcm@openssh.com},
      @item @tt {serpent128-gcm@libassh.org}, @tt {serpent256-gcm@libassh.org},
      @item @tt {twofish128-gcm@libassh.org}, @tt {twofish256-gcm@libassh.org},
    @end list

  @end section

  @section TP {Message authentication algorithms}
    @label {macalgos}

    Modules of this type are used by the @xref{transport
    layer} in order to authenticate the @em ssh2 packets transmitted
    over the network.

    Standard @em ssh2 MAC @xref {algorithms} based on @em{md5}, @em{sha1}
    and @em{sha2} are provided as specified in @sinvoke{4253}rfc and
    @sinvoke{6668}rfc. Extensions proposed by @em OpenSSH which use @em
    {Encrypt-then-Mac} instead of @em {Mac-then-Encrypt} are provided
    as well.

    MAC related declarations can be found in @ref{@assh/assh_mac.h}.

    The following MAC @xref {algorithms} have built-in support:
    @list
      @item @tt {hmac-md5}, @tt {hmac-md5-96},
      @item @tt {hmac-sha1}, @tt {hmac-sha1-96},
      @item @tt {hmac-sha2-256}, @tt {hmac-sha2-512},
      @item @tt {hmac-md5-etm@openssh.com}, @tt {hmac-md5-96-etm@openssh.com},
      @item @tt {hmac-sha1-etm@openssh.com}, @tt {hmac-sha1-96-etm@openssh.com},
      @item @tt {hmac-sha2-256-etm@openssh.com}, @tt {hmac-sha2-512-etm@openssh.com}.
    @end list

    When the @em Libgcrypt library is used, these additional MAC
    algorithms are available:
    @list
      @item @tt {hmac-ripemd160}, @tt {hmac-ripemd160-etm@openssh.com}
    @end list
  @end section

  @section TP {Compression algorithms}
    @label {compalgos}

    Modules of this type are used by the @xref{transport
    layer} in order to compress and decompress the @em ssh2 packets
    transmitted over the network.

    The following compression algorithms are supported when the @em
    Zlib library is available:

    @list
      @item @tt {zlib},
      @item @tt {zlib@openssh.com}
    @end list

    Compression algorithm declarations can be found in @ref{@assh/assh_compress.h}.
  @end section

  @section TP {User authentication methods}
    @label{uamethods}

    The @xref{user authentication} protocol is implemented as separate
    client and server service modules. The following standard
    authentication methods are supported by the provided modules:

    @list
      @item @tt none : always grant access.
      @item @tt password : transmit user password, checked on server side.
        The server may request change of password.
      @item @tt hostbased : grant access based on client machine
        @xref{host key}.
      @item @tt publickey : grant access based on @xref{user key}.
      @item @tt keyboard-interactive : prompt and transmit multiple
        text fields requested by the server.
    @end list

    Multi-factor authentication is supported on both sides. This means
    that the server application may require multiple methods to
    succeed in order to grant access. On the client side, multiple
    @xref{user authentication} events are reported until the server
    reports a success.
  @end section

  @section TP {Key types and formats}
    @label {keysalgos}
    @label {key formats} {key formats}

    The @em ssh2 protocol uses long term cryptographic key pairs in
    order to authenticate the hosts and users. A key pair is composed
    of a public part and a private part. Keys need to be transmitted
    over the network and stored on the file system. This implies that
    some key storage formats are specified.

    @section {Key types}
      There are various cryptographic algorithms which require
      different types of keys to be stored. Every supported type of
      key in @em libassh has its own support module which is able to
      load, save and create key pairs. The following types of keys
      have builtin support:

      @list
        @item @em{RSA} keys used for @xref{host authentication} and
          @xref{user authentication} as well as by the @em{RSA}
          @xref{kexalgos}{key-exchange algorithm},
        @item @em{DSA} keys used for host and user authentication only,
        @item @em{EDDSA} keys used for host and user authentication and
        @item @em{ECDSA} keys used for host and user authentication as well.
      @end list
    @end section

    @section {Key storage formats}
      Multiple @em ssh2 key storage formats are in wide use for every
      type of key. Some formats are specified in standard documents
      and others are proposed by specific implementations of @em
      {ssh2}.

      Existing formats are designed to store either the public part of a
      key or the whole key. Some are designed as containers
      which embed one or more key blobs encoded using a raw format.

      The library comes with a @xref{exkeygen}{key management} example
      application which is able to create new keys and convert between
      supported formats.

      @section {Raw formats}
        The raw formats are always binary and are handled in @em
        libassh key support modules directly. Not all raw formats are
        capable of storing any type of key. In order to support a
        given type of key, the format has to be designed to handle
        the specific set of values and blobs which compose the
        key. The following raw formats can be loaded and stored in
        memory by the key support modules:

        @list
          @item The binary format for public keys as described in
            @sinvoke{4253}rfc.
          @item The binary PEM format relying on @em{ASN1 DER}.
          @item The new @em{openssh-key-v1} key format.
        @end list
      @end section

      @section {Container formats}
        Most container formats are not tied to a specific type of key
        because they are generally designed as wrapper for raw
        formats. They may be binary or text based.

        They offer various features like storage of multiple key
        pairs, passphrase encryption of private keys and storage of
        metadata along with the raw key material.

        Support for these formats in @em libassh is provided as helper
        functions. Helpers are also provided which are able to load
        and save any format on the file system. Passphrase encryption
        of private keys is implemented when supported by the format.

        The following additional container formats are supported using
        @xref{helper functions} declared in @ref{@assh/helper_key.h}:

        @list
          @item The base64 format for public keys as described in
            @sinvoke{4716}rfc.
          @item The legacy base64 format for public keys used by @em
            OpenSSH.
          @item The PEM format wrapped in a base64 format similar to
            @sinvoke{2440}rfc, used by @em OpenSSH.
          @item The new @em{openssh-key-v1} key format.
      @end list

    @end section
    @end section
  @end section

@end section

@section TP {Examples}
  @label {example} {example}

  The section contains commented example applications based on
  @em libassh. There are client and server application examples as
  well as a key management tool application.

  The two first examples show very basic use of the library whereas
  the next examples make a more advanced use of the API.

  Each subsection cover a different example application available in
  the @tt {example/} directory of the package:

  @insert localtoc

  @section TP {Remote command execution}
    @label {exremote}

    The simple client application presented in this section is
    designed to connect to an @em ssh2 server and request execution of
    a command. It can be invoked like this:

    @code R
$ examples/client localhost ls
    @end code

    The first thing to do in the program @tt main function is
    initialization of the external libraries. @em libassh does
    not actually need this, but some other libraries like @em  Libgcrypt
    and @em OpenSSL used by @xref{coremod}{modules} may require
    calling a global initialization function. If you do not want to bother
    about which third party libraries are involved in your build of
    @em {libassh}, just call the @ref assh_deps_init function:
    @example examples/rexec.c:main P
    If you know that your build of @em libassh on your specific
    platform do not need this, you can skip this step.

    Our application then parse command line arguments and setups a TCP
    socket to the remote server. This part of the example code is not
    shown here. All it does is proper initialization of the @tt sock
    file descriptor and of the @tt command string variables from
    command line arguments.

    An @ref assh_session_s object is needed in order to store the
    state of the @em ssh2 protocol. This requires an @ref
    assh_context_s object used to store resources which may be shared
    by multiple @xref{sessions}.  That's why initializing a new
    library context is the first thing to do. Then
    @xref{coremod}{modules} need to be registered on the new context:
    @example examples/rexec.c:initc

    Our @ref assh_session_s object can then be initialized and
    attached to the context:
    @example examples/rexec.c:inits

    Our application will need to handle @xref{user authentication}
    related events originating from the server and reported by the
    library. That's why we have to keep track of @xref{user
    authentication} methods we want to use and that have not been
    tried yet:
    @example examples/rexec.c:inita

    In this simple application, we heavily rely on @xref{helper
    functions} provided by the library. This is the case for
    management of the @xref{interactive session} part of the
    @xref{connection protocol} which runs on the higher layer of @em
    {ssh2}. This component is used to request execution of a process
    on the remote server. It is not related to the @ref assh_session_s
    type presented above which is used to manage the whole connection.

    Even if more advanced applications will want to implement @xref
    {interactive sessions} directly, the library provides a small
    helper state machine which performs basic handling of client @xref
    {interactive sessions}. This is used below to handle @xref
    {request} and @xref {channel} related events in order to request
    execution the user command. At this point, we just need to
    initializes a state object for this helper:
    @example examples/rexec.c:initi

    Then comes the event loop, as described in the @xref {evts} section:
    @example examples/rexec.c:loop

    The IO events are reported by the library in order to let the
    application transfer the @em ssh2 stream over the network. In this
    examples, this is left to an helper function designed to read and
    write the stream using the application provided socket file
    descriptor:
    @example examples/rexec.c:evio

    Error notifications are also reported as events by the library.
    This event is handled without relying on an helper
    function. That's why the application has to take care of
    acknowledging the event by calling the @ref assh_event_done
    function:
    @example examples/rexec.c:everr

    Note that this event is only for notification and must not be used
    to exit the processing loop. The library may still report more
    events, allowing the application to clean open channels and other
    resources properly.

    Then come events that are only reported during specific phases of
    the protocol. Those are related to the @xref{key-exchange}
    process and to the currently running @xref{service}.

    When the server sends its @xref{host key} during @xref{key-exchange},
    our client needs to check if it is a known key or if the user
    accept the new key. An helper function handles this by looking in
    the @tt {~/.ssh/known_hosts} file. This helper also queries the user
    on the terminal if needed.

    @example examples/rexec.c:evhk
    The application could have handled this in a custom way
    in order to adapt the usage or support a specific target platform API.

    Once again an helper function is used to handle the
    @xref{user authentication} events. It takes care of
    querying the system user database and reads user public key
    files:
    @example examples/rexec.c:evua

    Then comes handling of the @xref{interactive sessions} as
    specified as part of the @xref{connection protocol}. It allows
    starting a process on a remote host. For that purpose, we rely on
    the helper state machine discussed previously. The @em ssh2
    protocol is able to multiplex many application @xref{channels}
    over a @xref{session}.  However, our simple tool only wants to
    start a single command, that's why we choose to properly shutdown
    the @em ssh2 @xref{session} when our single @xref{interactive
    session} ends:
    @example examples/rexec.c:evcn

    Because the library still needs to exchange packets in order to
    properly terminate the connection, we still have to run the loop
    after calling the @ref assh_session_disconnect function. The @ref
    assh_event_get function will stop reporting more events at some
    point, breaking our main loop as appropriate.

    Then comes handling of data transferred over the @xref{interactive
    session} @xref{channel}. When the remote command writes
    data to its standard output, the remote server forwards it to our
    client over the only existing @ref{assh_channel_s} object we
    have. We may then write the data to the standard output on the
    local side:
    @example examples/rexec.c:evdata

    We do not want to handle any other type of event that the library
    may report, but we still have to acknowledge them:
    @example examples/rexec.c:evdflt

    When we eventually exit from the loop, the @ref assh_session_s and
    @ref assh_context_s objects can be released:
    @example examples/rexec.c:cleanup
  @end section

  @section TP {Simple loopback server}
    @label {exloopback}

    This simple server application accepts all @xref{interactive
    session} open messages from a connecting client and send back any
    data received over open @xref{channels}. When connecting
    using a standard client, this has the effect of echoing any
    character typed.

    Unlike code of the @xref{exremote}{previous example} which handles
    @xref{connection protocol} related events using helper functions,
    those events are handled directly by the application here. This
    example also shows how to take control of the underlying channel
    flow control mechanism provided by the @em ssh2 protocol.

    In this server application, we use a single @ref assh_context_s
    object and different @ref assh_session_s objects for connecting
    clients. A single client can connect at the same time.  The
    context is initialized as shown previously:
    @example examples/loopback.c:initc P

    A server context needs to have some @xref{host keys}
    registered. We try to load @xref{host keys} from standard
    locations using an helper function. This may however require @tt
    root access. That's why we fallback to creating an ephemeral
    @xref{host key} by calling the @ref assh_key_create function:
    @example examples/loopback.c:reghk

    We can then start waiting for a client connection and initialize an
    @ref assh_session_s object when this occurs:
    @example examples/loopback.c:loop

    Then comes the @xref{event} loop:
    @example examples/loopback.c:loopev

    Some events are handled using helper functions, as detailed in the
    @xref{exremote}{previous example}:
    @example examples/loopback.c:helperev

    When the client sends an @ref SSH_MSG_CHANNEL_OPEN message to our
    server, this ends up reporting the @ref ASSH_EVENT_CHANNEL_OPEN
    event to the application. In our case, we want to allow the client
    to open @xref{channels} of the @tt session type. Other types of
    channel will be rejected by our server:
    @example examples/loopback.c:chopenev

    The @em ssh2 connection protocol provides a flow control mechanism
    for channels. This allows limiting the amount of data that the
    remote host is allowed to send through a channel. This amount is
    the window size. When the remote host has consumed a part of the
    window by sending data, the local side has to grant more window
    space again. This mechanism is implemented separately in both
    directions.

    Instead of letting the library manage the window size for us, we
    chose here to take control of the window size in the
    application. This is a wise choice in the case of a loopback
    server because we have to make sure that we will be able to send
    back any received data immediately. We do not want to be limited
    by the window size with some data that we would have to store
    until we are granted more window space. We need to have the window
    sizes synchronized between the two directions. That's why we grant
    the same initial window size and packet size as granted by the
    remote host in the opposite direction:
    @example examples/loopback.c:chopenwin

    When a channel open is acknowledged, the @ref assh_channel_s
    object pointed by @tt {ev->ch} lives until a close event is
    reported. In our simple example, we have no private context to
    attach and we do not need to keep track of it as further events
    will provide the pointer to the @ref assh_channel_s instance again.

    Setting the initial window size is not enough, we have to keep the
    window sizes of both directions in sync as data is exchanged over
    a channel. Because we disabled automatic window adjustment, we
    need to handle the @ref ASSH_EVENT_CHANNEL_WINDOW event and call
    the @ref assh_channel_window_adjust function. We want to increase
    our window size by the same amount that the remote side granted to
    us. This occurs when the event is reported:
    @example examples/loopback.c:evwin

    Note that we have to acknowledge the event before increasing the
    window size because most functions of the library can not be called
    between the pair of calls to @ref assh_event_get and @ref
    assh_event_done.

    A connecting client will request execution of a shell process on
    the server. Even if we only want to implement a loopback server,
    we need to fake acceptance of this request or the client may
    disconnect. This requires replying to channel related requests of
    the @tt shell type successfully:
    @example examples/loopback.c:rqev

    Then comes handling of the data transferred over the
    channels. When incoming data is reported by the library, we need
    to allocate a buffer in order to send the same amount of data back
    to the client. However, the current window size of the channel may
    not allow sending all the data, that's why the @ref
    assh_channel_data_alloc function is able adjust the size. In our
    case though, the function is guaranteed to let us allocate the
    requested size because of the control we have over the window size.
    @example examples/loopback.c:evdataalloc

    We must then update the event with the amount of incoming data we
    were able to consume. Again, we have to acknowledge the event before
    sending the data back.
    @example examples/loopback.c:evdatasend

    We are almost done with our loopback server. We still need to
    acknowledge other events:
    @example examples/loopback.c:evdflt

    When the connection closes, we cleanup the @xref{session} and we
    are ready to listen for an other connecting client:
    @example examples/loopback.c:sclean

  @end section

  @section TP {Command line client}
    @label {exclient}

    This example application is a classical ssh command line client
    for POSIX platforms.

    Our client has to handle multiple data streams to communicate with
    the remote host and drive the terminal. In order not to get
    blocked by an IO operation on one of the file descriptors, we need
    to use the @tt{poll} system call. This example shows how the API
    of @em libassh can be used to deal with this programming model,
    polling in both directions, so that neither @tt read nor @tt write
    calls are blocking.

    The details of the library initialization as well as other topics
    covered in the previous examples are not repeated here.

    The application is composed of two loops: the main loop which
    polls on the various file descriptors and the nested @em libassh
    event loop which handles the library events.

    @section {The main loop}
      We have four file descriptors based data endpoints to deal with:
      @list
        @item The incoming ssh network stream read from the @tt sock
          socket file descriptor,
        @item The outgoing ssh network stream transmitted over the same
          file descriptor,
        @item The terminal input read from standard input file
          descriptor 0,
        @item The terminal output written to the standard output file
          descriptor 1.
      @end list

      Before entering the main loop, we do declare an object of the
      @tt pollfd type in order to monitor the file descriptors:
      @example examples/client.c:pollstruct

      We need to transfer data between those file descriptors and the
      following interfaces provided by the library:
      @list
        @item The library network input pulled by the @ref
          ASSH_EVENT_READ events,
        @item The library network output pushed by the @ref
          ASSH_EVENT_WRITE events,
        @item The remote process output reported by the @ref
          ASSH_EVENT_CHANNEL_DATA events,
        @item The remote process input which can be sent over the
          channel by calling the @ref assh_channel_data_send function.
      @end list

      Because the @xref{interactive session} is not started immediately, only
      the network stream needs to be transferred initially. Moreover, we
      do not always have data to write to the file descriptors. That's
      why the @tt POLLIN and @tt POLLOUT flags are set conditionally on
      each iteration of the main loop.  The @ref assh_channel_more_data
      and @ref assh_transport_has_output functions are used to test if
      the library has some output data to report:
      @example examples/client.c:mainloop

      We are almost ready to call the @tt poll function. Because this
      system call is also able to return after a delay, it is useful to
      retrieve the next @em ssh2 protocol timeout delay from the
      library:
      @example examples/client.c:poll

      The application relies on an helper state machine in order to
      manage the @xref{interactive session}. Because we only want to
      run a single @xref{session}, we have to initiate a disconnection
      from the remote server when the single session terminates:
      @example examples/client.c:disco

      We can then start dealing with data transfer from the local
      standard input to the remote process input, provided that some
      data are available and the @xref{interactive session} has
      started. The data is written to the open @em ssh2 channel as
      explained in the previous example:
      @example examples/client.c:stdin

      If we are not able to read more data from the standard input, an
      end of file is reported to the remote host. If we are not able
      to write, a channel close is requested, which will makes the
      library report the @ref ASSH_EVENT_CHANNEL_CLOSE event.
      @example examples/client.c:close

      As stated previously, the other data transfers are performed
      when the library reports events. We then need to handle @em
      libassh events at this point.  We use an other loop to process
      those events. This nested loop handle as many events as possible
      without blocking.  This loop is in implemented in the separate
      @tt ssh_loop function:
      @example examples/client.c:sshloopcall|cleanup

      The @tt ssh_loop function returns 0 if there are no more events
      to report, which means the end of the @em ssh2 @xref{session}
      and makes the main loop terminate.
    @end section

    @section {The assh event loop}
      The @tt ssh_loop function contains the @em libassh
      @xref{event} loop as stated previously:
      @example examples/client.c:sshloop

      Only data transfer related events are shown here, as handling of
      other events mostly rely on helpers functions that deal with
      @xref{user authentication} and @xref{interactive session}
      management. This is detailed in the @xref{exremote}{remote
      command execution} example.

      Because the @ref ASSH_EVENT_READ event needs data to be
      available from the socket file descriptor, the loop is
      interrupted if the @tt poll system call did not allow us to @tt
      read yet. We yield to the IO polling loop in this case.
      @example examples/client.c:eventread

      The event processing loop is interrupted just before trying any IO
      operation which may block.  The @tt POLLIN flag is cleared so that
      a single @tt read is allowed between calls to the @tt poll function.

      The same mechanism is used for @tt write calls:
      @example examples/client.c:eventwrite

      Transferring data from the channel to the terminal requires more
      work because no helper function is used, but the approach is still
      the same:
      @example examples/client.c:eventdata

      The event handling loop ends as usual:
      @example examples/client.c:eventother
    @end section

  @end section

  @section TP {UNIX server}
    @label {exserver}

    This example application is a server able to handle @xref {connection
    sharing}. Multiple @xref{interactive sessions} on the server side
    runs separate processes started by a single client. The server
    code executes in the parent process and relies on @em libassh in
    order to manage the connection with the client and the children IO
    streams.

    We first introduce a few functions designed to execute a child
    process and setup related IO redirections. This is the @xref{interactive
    session} management code, provided by the application. Then we
    detail code of the event loops used to run the ssh server
    @xref{session}. Those loops are similar to what is implemented in the
    @xref{exclient}{client example} application, but multiple channels
    and IO streams are involved here.

    @section {Interactive session code}
      The states of @xref{interactive sessions} are stored in instances of
      the @tt its_s structure we declare below. Our server application
      has to create those objects when execution of a new @xref{interactive
      session} is requested by the client.

      This structure contains a state field along with a reference to
      the associated @em libassh channel, as well as some child process
      handles:
      @example examples/server.c:state

      Our small finite state machine tracks the status of an
      @xref{interactive session} and is updated by the functions presented in
      this section. Here are the existing states:
      @example examples/server.c:fsm

      Because the main loop needs to @tt poll on file descriptors
      associated with all child processes, we have to keep track of
      existing @tt its_s objects in a table:
      @example examples/server.c:itstable

      The application functions described below do manage the @tt
      its_s instances. This consists in calling @em POSIX functions in
      order to create the child process and redirect its IOs. The
      content of these functions is not detailed here because an
      explanation of their behavior is enough to understand the @em
      libassh related part of the application that follows.

      The @tt its_open function allocates a new @tt its_s object, set
      its state to @tt {ITS_PIPE} and store a reference to the
      channel associated to the @xref{interactive session}:
      @example examples/server.c:itsapiopen

      The @tt its_pty function changes the state from @tt
      {ITS_PIPE} to @tt {ITS_PTY}. This is an optional step
      before calling the @tt its_exec function which allows using a
      @sinvoke{Pseudoterminal} {pseudo terminal}wp device to redirect
      the child process IOs instead of relying on some
      @sinvoke{Anonymous pipe} {file descriptor pipes}wp.
      @example examples/server.c:itsapipty

      The @tt its_exec function @tt fork the current process, @tt exec
      the requested child command and setup redirections of its
      IOs. This also makes the state of our @xref{interactive session} object
      change to @tt {ITS_OPEN}.
      @example examples/server.c:itsapiexec

      The following three functions are used to mange the flow of data
      between the @em ssh2 channels and the child processes.

      The @tt its_poll_setup function is used to append some @tt
      pollfd entries for monitoring child IO file descriptors prior
      to invoking @tt poll in the main loop:
      @example examples/server.c:itsapipoll

      The @tt its_child2channel function is then used to handle @tt
      POLLIN events reported by @tt poll. It processes child input and
      pushes data to the @xref{interactive session} associated channel. This
      function is also responsible for closing and half closing the
      channel when an IO error is reported by @tt poll. In this case,
      the state is changed to @tt {ITS_HALF_NO_SEND} or @tt {ITS_CLOSED}.
      @example examples/server.c:itsapidata

      Data flow in the other direction is handled when @em libassh
      reports incoming channel data from the remote host. This is
      handled by the @tt its_channel2child function which writes the
      incoming data to the standard input of the child process.
      @example examples/server.c:itsapidata2

      Finally, the @tt its_eof and @tt its_close functions are called
      when the library report that the remote client has closed its
      data streams. The @tt its_eof function changes the state of the
      @xref{interactive session} object to @tt {ITS_HALF_NO_RECV} or @tt
      {ITS_CLOSED} depending on the previous state. The @tt its_close
      function simply releases the @tt its_s instance.
      @example examples/server.c:itsapiclose
    @end section

    @section {The assh event loop}
      The event loop has the same layout as in the
      @xref{exclient}{client example}:
      @example examples/server.c:evloop
      Handling of the @ref ASSH_EVENT_READ, @ref ASSH_EVENT_WRITE and
      @ref ASSH_EVENT_ERROR events has already been covered and is not
      detailed again.

      The @xref{user authentication} relies on helper functions. When
      the authentication is successful, the user ID of the current
      process is changed. This is handled by the following simple
      code:
      @example examples/server.c:evauth

      Then comes the @xref{channels} and @xref{requests} related
      events. This is where our @xref{interactive session} objects are
      created and managed thanks to the functions defined above.

      Our server has to accept channel open messages from the client
      when starting an @xref{interactive session} is requested. This is the
      case when the channel type reported by the @ref
      ASSH_EVENT_CHANNEL_OPEN event is @tt {"session"}. The library then
      keeps the channel object alive until the @ref
      ASSH_EVENT_CHANNEL_CLOSE event is reported.
      @example examples/server.c:evchopen

      Because requests are used to let the client select the command
      it wants to run on the server, we have to handle the @ref
      ASSH_EVENT_REQUEST event as well. Any such request can only be
      related to one of the channel we just accepted to open. That's
      why we are able retrieve the pointer to our associated @tt its_s
      object we have attached previously. Global requests are rejected.
      @example examples/server.c:evrq

      The @tt {"pty-req"} request may optionally be used by the
      client. This requires us to call our @tt its_pty function
      discussed previously. The @ref assh_inter_decode_pty_req helper
      function is used here to validate and decode the data attached
      to the request but its content is not used in this simple
      server.
      @example examples/server.c:evrqpty

      When the client eventually requests execution of a @tt {"shell"}
      process, the @tt its_exec function is called:
      @example examples/server.c:evrqshell

      If instead the client requests execution of an arbitrary
      command, a similar action is performed. In this case we need to
      parse the data attached to the request in order to get the
      command string before calling the @tt its_exec function:
      @example examples/server.c:evrqexec

      Finally, this event needs to be acknowledged, as usual:
      @example examples/server.c:evrqdone

      The client may request half-closing the channel if it has no
      more data to transmit. When this occurs, the @ref
      ASSH_EVENT_CHANNEL_EOF event is reported and we rely on our @tt
      its_eof function to handle it:
      @example examples/server.c:eveof

      In any case, @em libassh will report the @ref
      ASSH_EVENT_CHANNEL_CLOSE event at some point. This may be due to
      the client properly requesting close of a single channel or due
      to a lost connection. This behavior of @em libassh ensures that
      we will always be able to properly release resources we have
      attached to channels.
      @example examples/server.c:evclose

      Incoming channel data is handled by our @tt its_channel2child
      function described previously. If we are not sure it's possible
      to write to the child without blocking according to the @tt
      pollfd array, the function returns @tt 1 and we have to break
      the @em libassh event loop and yield to the IO event loop:
      @example examples/server.c:evdata

      Any other event is simply acknowledged as usual:
      @example examples/server.c:evother
    @end section

    @section {The IO event loop}
      The function below is executed in a new process when a client
      connects to the server. It creates a new @em libassh
      @xref{session} and starts the IO polling loop:
      @example examples/server.c:connected

      The @tt poll system call is used to monitor the network
      connection to the client as well as IOs of @xref{interactive session}
      child processes. Our @tt its_poll_setup function will
      fill the @tt pollfd array with @xref{interactive session} related
      entries.
      @example examples/server.c:pollloop

      As shown previously, the @tt poll function is also used to let
      the library check ssh protocol timeouts:
      @example examples/server.c:poll

      Our @tt its_child2channel function may now do its job of
      transferring data from the child processes to the remote client:
      @example examples/server.c:chi2cha

      The libassh event loop is then executed and may decide to wait
      for more IO events or terminate the connection:
      @example examples/server.c:loopcall
    @end section

    @section {The main loop}
      Our server main loop implements a simple forking server. Note
      that the maximum number to connections is not limited.
      @example examples/server.c:mainloop
    @end section
  @end section

  @section TP {SSH key management tool}
    @label {exkeygen}

    This examples application parses the command line arguments and
    performs user and @xref{host keys} related operations. It relies
    on the @ref assh_key_create, @ref assh_load_key_file, @ref
    assh_key_validate and @ref assh_save_key_file functions provided
    by the library.

    Here is how it can be invoked in order to generate a new
    @xref{user key}:

    @code R
$ examples/keygen create -t ssh-rsa -o ~/.ssh/id_rsa
Generating key...
Saving key in pem_pv format...
Output key passphrase:
Done.
    @end code

    The previous command only generates and stores the private key. The
    associated public key can be extracted with an other invocation:

    @code R
$ examples/keygen convert -f openssh_pub -i ~/.ssh/id_rsa -o ~/.ssh/id_rsa.pub
Loading key...
Input key passphrase:
Key type: ssh-rsa (private)
Saving key in openssh_pub format...
Done.
    @end code

    @c  @example examples/keygen.c
  @end section
@end section

@section TPe {API documentation}

  @section THe {Headers list}
    @insert {header} compound_table
  @end section

  @insert {header} all_compound_sections

  @section PTHe {All declarations}
    @insert global_scope_doc
  @end section

@end section

@section TP {SSH Lexicon}

  The section briefly explains some terms that have a specific
  meaning when used in the context of the @em ssh2 protocol.

  @section {Algorithm}
    @label{algorithms} {algorithms}

    @em {ssh2 algorithms} are named and interchangeable software
    components used to secure the connection. They are negotiated
    during the @xref{key-exchange} process. @xsee{suppalgos} @see
    assh_algo_s
    @see{@assh/assh_algo.h}
  @end section

  @section {Channel}
    @label{channels} {channels}

    A @em{channel} allows the application to transmit a stream
    of data over @em {ssh2}. The channel mechanism is specified as
    part of the @xref{connection protocol}.
    @xsee {connlayer} @see assh_channel_s
  @end section

  @section {Connection}
    This term refers to the link used by the @xref{transport layer},
    established between a client and a server which lasts for the time
    of a @xref{session}. The term @em {transport layer connection} is
    used in the specification. This must not be confused with the term
    @xref{connection protocol}.  @xsee{trlayer}
  @end section

  @section {Connection protocol}
    The @em {connection protocol} is a component of the @em ssh2
    protocol specified as a @xref{service}. It is the higher layer of
    the protocol. It provides the @xref{channel} and @xref{request}
    mechanisms used by the application.
    @xsee {connlayer}
    @see{@assh/assh_connection.h}
  @end section

  @section {Connection sharing}
    Some @em ssh2 implementations are able to run multiple
    @xref{interactive sessions} over a single @em ssh2 @xref{session},
    as allowed by the specification.
  @end section

  @section {Fingerprint}
    An SSH key @em{fingerprint} is a human readable hash value which
    allows the user to visually check whether two @xref{Host keys} are
    the same.
  @end section

  @section {Global request}
    A @em{global request} is a @xref{request} which is not associated
    to a @xref{channel}. @xsee {connlayer}
  @end section

  @section {Host authentication}
    The @em {Host authentication} mechanism allows the client to make
    sure it is establishing a @xref{session} with the expected
    server. It takes place during the @xref{key-exchange} process and
    involves the server @xref{Host key}. @xsee{authalgos}
  @end section

  @section {Host based user authentication}
    The @em {host based user authentication} method is one of the user
    authentication mechanism optionally provided by the @xref{user
    authentication} service. It allows the client application to
    authenticate its user on the server based on the @xref{host key}
    of the host which is running the client. @xsee{srvlayer}
  @end section

  @section {Host key}
    @label {Host keys} {Host keys}

    A host key is an @xref{SSH key} kept by a server host. It is
    mainly used to perform @xref{host authentication} during the
    @xref{key-exchange} and may also be involved in the @xref{Host
    based user authentication} method.
  @end section

  @section {Interactive session}
    @label {interactive sessions} {interactive sessions}

    The term @em{Interactive session} relates to a feature of the
    @xref{connection protocol} designed to let a client run a process
    remotely, on top of @em {ssh2}. It is not related to the term
    @xref{session}. @xsee {connlayer}
  @end section

  @section {Key-exchange}
    The @em {key-exchange} is a part of the @em ssh2 protocol designed
    to establish the server @xref{host authentication}{host
    authenticity} and generate the @xref{session keys}.
    @xsee{kex} @xsee{kexalgos}
    @see{@assh/assh_kex.h}
  @end section

  @section {Message}
    Every @em ssh2 binary packets carries a single @em {message} which
    has a specific role in the protocol. @xsee{trlayer}
    @see assh_ssh_msg_e
    @see{@assh/assh_packet.h}
  @end section

  @section {Port forwarding}
    The term @em{Port forwarding} relates to a feature of the
    @xref{connection protocol} designed to make the server act as a
    proxy which issues and accepts some TCP connections on the behalf
    of the client. @xsee {connlayer}
  @end section

  @section {Private extension}
    @label {private extensions} {private extensions}

    @em ssh2 support for @em {private extensions} allows
    implementations to provide some specific or advanced features not
    described in the standard, provided that they are properly
    negotiated.
  @end section

  @section {Public key user authentication}
    @label {public key authentication} {public key authentication}

    The @em {public key user authentication} method is one of the user
    authentication mechanism provided by the @xref{user
    authentication} service. When selected, it allows the client
    application to authenticate its user on the remote server based on
    the ownership of the private part of an @xref{user
    key}. @xsee{srvlayer} @xsee{authalgos}
  @end section

  @section {Request}
    @label{requests} {requests}

    @em{ssh2 requests} are used by applications to transmit control
    messages to the remote host. There are specified as part of the
    @xref{connection protocol}. @xsee {connlayer}
    @see assh_request_s
  @end section

  @section {Service}
    @label {services} {services}

    A service is a type of software component which runs on top of the
    @xref{transport layer}.
    @xsee{trlayer}
    @see assh_service_s
  @end section

  @section {Session}
    @label {sessions} {sessions}
    A @em{session} is initiated by a client when it connects to a
    server.  It gets established when the @xref{key-exchange} process
    produces an unique session identifier as well as the @xref{session
    keys}. This must not be confused with the term @xref{interactive
    session}.
    @see assh_session_s
  @end section

  @section {SSH key}
    @label {SSH keys} {SSH keys}

    @em{SSH keys} are a long term cryptographic keys mainly used along
    with signature @xref{algorithms}. An @em{SSH key} can be used as
    an @xref{User key} or as a @xref{Host key}. Because it relies on
    public key cryptography, it has a public part and a private part.
    @xsee{keysalgos} @see assh_key_s
    @see{@assh/assh_key.h}
  @end section

  @section {Transport layer}
    The @em{transport layer} is a component of the ssh protocol
    designed to enable secure communication over the @xref{connection}
    during the whole @xref{session}. @xsee{trlayer}
    @see{@assh/assh_transport.h}
  @end section

  @section {User authentication}
    The @em {user authentication} component is specified as a
    @xref{service} of the @em ssh2 protocol. It allows the client
    application to authenticate its user on the remote server system.
    @xsee{srvlayer}
    @xsee{uamethods}
    @see{@assh/assh_userauth_server.h}
    @see{@assh/assh_userauth_client.h}
  @end section

  @section {User key}
    An user key is an @xref{SSH key} used to authenticate the user on
    the remote server. It is only used when the @xref{public key user
    authentication} method is selected.
  @end section

  @section {Session keys}
    @em{Session keys} are ephemeral keys used by symmetric
    cryptography @xref{algorithms} to perform encryption and
    authentication of the @em ssh2 binary packets exchanged over the
    insecure @xref{connection}. @xsee{kex}
  @end section

  @section {Version string}
    @label {version strings} {version strings}

    The @em {version strings} transmitted on connection allows to
    identify the remote @em ssh2 software vendor and revision.
    @xsee{trlayer}
  @end section

@end section

@section TP {Copyright and license}

  @section T {Software License}
    @label {license} {license}

    The @em libassh source code is covered by the @b{GNU Lesser General
    Public License, Version 2.1}.

    This license allows using the library from a non-free application
    but requires publishing modifications made to the code of library
    itself. Contact the author for more details.

    As a special exception, source code of example applications found
    in the @tt {example/} directory and source code of the @tt
    helper_client and @tt helper_server files may be freely copied
    without causing the resulting work to be covered by the LGPL.
  @end section

  @section T {Copyright owner}
    As of version 1.0 of @em libassh, @em{Alexandre Becoulet} is the
    copyright owner of the whole source code of @em libassh.
  @end section

  @section T {Derivative work}
    As of version 1.0 of @em libassh, @em{Alexandre Becoulet} is the
    original author of the whole source code of the library core and
    the original author of most modules. Modules and helpers
    containing derivative work are listed here:

    @list
      @item In the @tt {chacha20-poly1305@openssh.com} cipher module,
        the implementation of the @em Poly1305 algorithm is based on a
        @b{public domain} implementation by @em{Andrew Moon}.
      @item In the @tt{hash_sha2_builtin.c} file, the builtin SHA2
        module is based on a @b{public domain} implementation by
        @em {Christophe Devine}.
      @item In the @tt{hash_sha1_builtin.c} file, the builtin SHA1
        module is based on a @b{public domain} implementation by
        @em {Steve Reid}.
      @item In the @tt{hash_md5_builtin.c} file, the builtin MD5
        module is based on a @b{public domain} implementation by
        @em {Colin Plumb}.
      @item In the @tt{helper_bcrypt.c} file, the @em bcrypt algorithm
        implementation is based on @em OpenSSH source code by @em {Ted
        Unangst}, released under a @b{BSD license}. It enables support for
        passphrase encrypted public key files used by @em OpenSSH.
    @end list

  @end section

  @section T {Copying this document}
    Copyright (C) 2013-2018 @em{Alexandre Becoulet}. Permission is
    granted to copy, distribute and/or modify this document under the
    terms of the @b{GNU Free Documentation License, Version 1.3} or
    any later version published by the Free Software Foundation; with
    no Invariant Sections, no Front-Cover Texts, and no Back-Cover
    Texts. A copy of the license is included in the section entitled
    @xref{GNU Free Documentation License}.
  @end section

@end section

@section TPe {Bibliography}

  @bib{analy01} Williams S.C. (2011) Analysis of the SSH Key Exchange Protocol. In: Chen L. (eds) Cryptography and Coding. IMACC 2011. Lecture Notes in Computer Science, vol 7089. Springer, Berlin, Heidelberg
  @bib{model01} P. Fiterau-Brostean, Toon Lenaerts, E. Poll, J. de Ruiter, F.W. Vaandrager, and P. Verleg. Model Learning and Model Checking of SSH Implementations. In Proceedings 24th ACM SIGSOFT International SPIN Symposium on Model Checking of Software, 13-14 July 2017, Santa Barbara, CA, USA, pages 142-151. ACM, NY, 2017.
  @bib{infer01} Vaandrager, F.W. Inferring SSH state machines using protocol state fuzzing.
  @bib{model02} Tijssen, M.: Automatic modeling of ssh implementations with state machine learning algorithms. Bachelor's thesis, Radboud University Nijmegen (June 2014).
  @bib{trspec01} Erik Poll and Aleksy Schubert, Rigorous specifications of the SSH transport layer.
  @bib{curve25519libssh} Aris Adamantiadis, description of the @em{curve25519-sha256@libssh.org.txt} algorithm
  @bib{curve25519} Curve25519: new Diffie-Hellman speed records
  @bib{ietfladdsc} IETF draft-ladd-safecurves-04
  @bib{safecurves} @url {http://safecurves.cr.yp.to} {SafeCurves}: choosing safe curves for elliptic-curve cryptography
  @bib{rfc2440} @url {https://tools.ietf.org/html/rfc2440}{rfc2440} : OpenPGP Message Format
  @bib{rfc4250} @url {https://tools.ietf.org/html/rfc4250}{rfc4250} : The Secure Shell (SSH) Protocol Assigned Numbers
  @bib{rfc4251} @url {https://tools.ietf.org/html/rfc4251}{rfc4251} : The Secure Shell (SSH) Protocol Architecture
  @bib{rfc4252} @url {https://tools.ietf.org/html/rfc4252}{rfc4252} : The Secure Shell (SSH) Authentication Protocol
  @bib{rfc4253} @url {https://tools.ietf.org/html/rfc4253}{rfc4253} : The Secure Shell (SSH) Transport Layer Protocol
  @bib{rfc4254} @url {https://tools.ietf.org/html/rfc4254}{rfc4254} : The Secure Shell (SSH) Connection Protocol
  @bib{rfc4255} @url {https://tools.ietf.org/html/rfc4255}{rfc4255} : Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints
  @bib{rfc4256} @url {https://tools.ietf.org/html/rfc4256}{rfc4256} : Generic Message Exchange Authentication for the Secure Shell Protocol (SSH)
  @bib{rfc4344} @url {https://tools.ietf.org/html/rfc4344}{rfc4344} : The Secure Shell (SSH) Transport Layer Encryption Modes
  @bib{rfc4419} @url {https://tools.ietf.org/html/rfc4419}{rfc4419} : Diffie-Hellman Group Exchange for the Secure Shell (SSH) Transport Layer Protocol
  @bib{rfc4432} @url {https://tools.ietf.org/html/rfc4432}{rfc4432} : RSA Key Exchange for the Secure Shell (SSH) Transport Layer Protocol
  @bib{rfc4716} @url {https://tools.ietf.org/html/rfc4716}{rfc4716} : The Secure Shell (SSH) Public Key File Format
  @bib{rfc5647} @url {https://tools.ietf.org/html/rfc5647}{rfc5647} : AES Galois Counter Mode for the Secure Shell Transport Layer Protocol
  @bib{rfc5656} @url {https://tools.ietf.org/html/rfc5656}{rfc5656} : Elliptic Curve Algorithm Integration in the Secure Shell Transport Layer
  @bib{rfc6668} @url {https://tools.ietf.org/html/rfc6668}{rfc6668} : SHA-2 Data Integrity Verification for the Secure Shell (SSH) Transport Layer Protocol
  @bib{draftmodp} draft-ietf-curdle-ssh-modp-dh-sha2-05
  @bib{fips1864} @em {FIPS 186.4}
  @bib{draftsignsha2} @em{IETF draft-rsa-dsa-sha2-256-03}
  @bib{hshssign} @em {High-speed high-security signatures}

@end section

@section TP {Appendix}
  @section {Transport state diagram}
    @label {fsmtr}
    @image transport.png
  @end section

  @section {Input state diagram}
    @label {fsmin}
    @image transport_in.png
  @end section

  @section {Output state diagram}
    @label {fsmout}
    @image transport_out.png
  @end section

  @section {Service state diagram}
    @label {fsmsrv}
    @image service.png
  @end section

  @section {Client user authentication state diagram}
    @label {fsmcauth}
    @image userauth_client.png
  @end section

  @section {Server user authentication state diagram}
    @label {fsmsauth}
    @image userauth_server.png
  @end section

  @section {Channel state diagram}
    @label {fsmchan}
    @image connection_channel.png
  @end section

  @section {Request state diagram}
    @label {fsmrq}
    @image connection_request.png
  @end section
@end section

@section TP {GNU Free Documentation License}
  @include fdl-1.3.mkdoc
@end section

