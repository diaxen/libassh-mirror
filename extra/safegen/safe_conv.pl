#!/usr/bin/perl

#  Safe prime number header generation tool for libassh.
#
#  Copyright (C) 2016 Alexandre Becoulet <alexandre.becoulet@free.fr>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation; either version 2.1 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#  02110-1301 USA

use strict;
my @a;
my @s;
my @p;

open(IN, "<safe_primes.txt") or die;
open(OUT, ">safe_primes.h") or die;

foreach (<IN>) {
    die unless /^bits:(\d+) poly:(\w+) seed:(\w+) offset:(\w+)$/;

    my ($bits, $poly, $seed, $offset) = ($1, oct($2), oct($3), oct($4));

    my $sp = \@s[($bits - 1024) / 4096];
    if (defined $$sp) {
	die if $$sp != $seed;
    } else {
	$$sp = $seed;
    }

    my $pp = \@p[($bits - 1024) / 4096];
    if (defined $$pp) {
	die if $$pp != $poly;
    } else {
	$$pp = $poly;
    }

    @a[$bits] = $offset;
}

printf OUT '

/* This file has been generated by safe_conv.pl */

#ifndef ASSH_SAFEPRIME_H_
#define ASSH_SAFEPRIME_H_

#include "assh.h"

/** @internal
    The output of @ref assh_safeprime_lfsr with the most significant bit
    forced to 1, interpreted as a big number stored least significant
    byte first, serve as base value to forge a safe prime. A value from
    the assh_safeprime_offset array must be added to the base value in
    order to obtain a safe prime number. The array contains offsets for
    number bit sizes multiple of 8 between 1024 and 16384 bits.

    The lfsr polynomial and base seed used to generate the base values
    are shared by at most 1024 numbers. This allows updating only a
    subset of the safe prime numbers. The seed used to generate a specific
    base value is obtained by xoring the base seed and the number bit
    size. */
struct assh_safeprimes_s
{
  uint32_t poly[4];
  uint32_t seed[4];
  uint32_t offset[1921];
};

/** @internal @see assh_safeprimes_s */
ASSH_INLINE void
assh_safeprime_lfsr(uint8_t *data, size_t len, uint32_t poly, uint32_t seed)
{
  while (len--)
    {
      seed = (~((seed & 1) - 1) & poly) ^ (seed >> 1);
      *data++ = seed ^ (seed >> 8) ^ (seed >> 16) ^ (seed >> 24);
    }
}

/** @internal @This generates a base value and offset suitable to generate
    a safe prime number of the requested bit size. @see assh_safeprimes_s */
ASSH_INLINE void
assh_safeprime_get(const struct assh_safeprimes_s *desc, size_t bits,
		   uint8_t *bignum, intptr_t *offset)
{
    assert(bits % 8 == 0 && bits >= 1024 && bits <= 16384);
    uint32_t poly = desc->poly[(bits - 1024) / 4096];
    uint32_t seed = desc->seed[(bits - 1024) / 4096];
    assh_safeprime_lfsr(bignum, bits / 8, poly, seed ^ bits);
    bignum[bits / 8 - 1] |= 0x80;
    *offset = desc->offset[(bits - 1024) / 8];
}

static const struct assh_safeprimes_s assh_safeprimes = {
 .poly = { 0x%08x, 0x%08x, 0x%08x, 0x%08x },
 .seed = { 0x%08x, 0x%08x, 0x%08x, 0x%08x },
 .offset = {
    ', @p[0], @p[1], @p[2], @p[3], @s[0], @s[1], @s[2], @s[3];

my $j = 1;
for (my $i = 1024; $i <= 16384; $i += 8) {
    my $o = @a[$i];
    die "missing $i\n" unless defined $o;
    print OUT "/* $i bits */\n    " if (($i - 1024) % 4096 == 0);
    printf OUT "0x%08x,%s", $o, $j++ % 8 ? " " : "\n    ";
}

printf OUT "
  }
};

#endif
";
